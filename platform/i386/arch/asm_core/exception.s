;
; This program is free software; you can redistribute it and/or
; modify it under the terms of the GNU General Public License
; as published by the Free Software Foundation; either version 2
; of the License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (C) Roger George Doss. All Rights Reserved
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	
;	@module
;		exception.s
;
;	@description
;		Handles all low-level CPU exceptions
;
;	@author
;		Roger George Doss
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	include files
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include "common/macros.inc"
%include "common/cdef.inc"
%include "common/proc.inc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	external symbols
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
extern common_handler_return		; syscall.s

;
; These place the address of the handler routine
; at the top of the stack prior to the actual push
; of the registers.  This allows us to build the
; stack and to access the handler when needed.
; The stack at this point looks like this:
;
; SS
; ESP
; EFLAGS
; CS
; EIP
; ERROR CODE { for certain exceptions }
;
; The frame to be pushed on the stack is 0x30 bytes
; in size ( see cpu_ctx.h and ./common/ctx.inc ).
; 
; After that, we want to have the error code
; at address 0x34 and the handler address at
; address 0x38.  In the common code, the handler
; is exchanged with a pointer to the stack frame
; and is passed to the handler as the first argument.
; Thus, the handler has the following signature:
;
; void handler ( struct cpu_ctx *ctx, unsigned error )
;
; For Exceptions that have no error code, we push an
; artifical error code of -1 on the stack in place
; of the tmp field in the stack frame, and assign
; the error parameter the value of 0.
;
; For Exceptions with error code, we move the
; error code pushed by the hardware to the error
; parameter, and assign an artificial error
; code of -1 on the stack in place of the tmp
; field in the stack frame.
;
; The NO_ERROR_HANDLER moves the handler's address
; to address x0x3C because at this time, there
; is no error code on the stack, and hence, we are
; off by 0x4 bytes.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%macro ERROR_HANDLER 1
	mov dword [esp - 0x38],%1
	jmp excpt_error
	%endmacro

%macro NO_ERROR_HANDLER 1
	mov dword [esp - 0x3C],%1
	jmp excpt_no_error
	%endmacro

;
;	no error code exceptions
; 
extern do_divide_error			; arch/i386/exception.c
extern do_debug
extern do_nmi
extern do_int3
extern do_overflow
extern do_bounds
extern do_invalid_operation
extern do_device_not_available
extern do_coprocessor_segment_overrun
extern do_reserved
extern do_coprocessor_error

;
;	error code exceptions
;
extern do_invalid_TSS
extern do_segment_not_present
extern do_stack_segment
extern do_general_protection
extern do_alignment_check
extern do_page_fault
extern do_double_fault

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	assembly macros and constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;	Common exception handler.
;
excpt_no_error:
	push dword -1                   	; tmp now  -1
        mov dword [esp - 0x34],0        	; set error paramter to 0
	jmp excpt_common_handler

excpt_error:
	sub esp,0x30				; reserve the 0x30 bytes for the stack frame
        push dword [esp + 0x30]         	; set error parameter with what was on the stack as pushed by the CPU
        mov  dword [esp + 0x34],-1      	; tmp now -1
        add  esp,0x34                   	; restore stack pointer

excpt_common_handler:
	CTX_SAVE				; build the stack frame

	mov  eax,0				; disable debug exceptions generated by hardware
	mov  dr7,eax

	mov  dword edx,KERNEL_DS		; set kernel data segment
	mov  word   ds,dx
	mov  word   es,dx

	mov  dword edx,USER_DS			; set user data segment
	mov  word   fs,dx

	mov  dword eax,[current_process]	; setup current process pointer

	mov  dword edx,dr6			; get debugging information from debug 6
	mov  dword [__PROC_DBGREG6__ + eax],edx	; and store in current_process

	sub esp,8               		; expose handler and error code
        lea eax,[esp + 8]       		; obtain pointer to the ctx frame
        xchg [esp],eax          		; exchange the handler with the pointer to the ctx frame
        call eax                		; call handler: void handler( struct cpu_ctx *ctx, unsigned error )

        add esp,8               		; restore the stack, it now points to the actual frame
						; the common handler return code restores stack frame
						; and removes the error code { it does not matter if its our's  or CPU's }
						; iretd expects the eip, cs, eflags on the top of the stack like ret
						; expects eip on the top of the stack
	jmp common_handler_return		; the handler checks for pending defint's and signals, as well as does
						; some changes to eflags prior to calling iretd

;
;	Exceptions with no error code.
;	The kernel pushes an artificial error
;	code of 0 on the stack in this case.
;
C_ENTRY excpt_divide_error
	NO_ERROR_HANDLER do_divide_error

C_ENTRY excpt_debug
	NO_ERROR_HANDLER do_debug

C_ENTRY excpt_nmi
	NO_ERROR_HANDLER do_nmi

C_ENTRY excpt_int3
	NO_ERROR_HANDLER do_int3

C_ENTRY excpt_overflow
	NO_ERROR_HANDLER do_overflow

C_ENTRY excpt_bounds
	NO_ERROR_HANDLER do_bounds

C_ENTRY excpt_invalid_operation
	NO_ERROR_HANDLER do_invalid_operation

C_ENTRY excpt_device_not_available
	NO_ERROR_HANDLER do_device_not_available

C_ENTRY excpt_coprocessor_segment_overrun
	NO_ERROR_HANDLER do_coprocessor_segment_overrun

C_ENTRY excpt_reserved
	NO_ERROR_HANDLER do_reserved

C_ENTRY excpt_coprocessor_error
	NO_ERROR_HANDLER do_coprocessor_error

;
;	Exceptions with error codes.
;	Intel 80x86 processors handle these
;	exceptions by autmatically pushing an
;	error code on the stack.
;
C_ENTRY excpt_invalid_TSS
	ERROR_HANDLER do_invalid_TSS

C_ENTRY excpt_segment_not_present
	ERROR_HANDLER do_segment_not_present

C_ENTRY excpt_stack_segment
	ERROR_HANDLER do_stack_segment

C_ENTRY excpt_general_protection
	ERROR_HANDLER do_general_protection

C_ENTRY excpt_alignment_check
	ERROR_HANDLER do_alignment_check

C_ENTRY excpt_page_fault
	ERROR_HANDLER dword do_page_fault

C_ENTRY excpt_double_fault
	ERROR_HANDLER do_double_fault

;
; EOF
;
